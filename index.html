<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lista de Canales</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fondo oscuro */
            color: #e2e8f0; /* Texto claro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Evita scroll */
            position: relative; /* Necesario para posicionar la lista encima */
        }
        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Fondo negro para el reproductor */
            z-index: 5; /* Debajo de la lista */
        }
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Asegura que el video se ajuste sin distorsión */
        }
        .channel-list-container {
            position: absolute;
            top: 0;
            left: 0; /* Posicionar a la izquierda */
            width: 300px; /* Ancho fijo o relativo según preferencia */
            height: 100%;
            background-color: rgba(26, 32, 44, 0.95); /* Fondo oscuro semi-transparente */
            display: flex;
            flex-direction: column; /* Apilar elementos verticalmente */
            padding: 1rem;
            z-index: 10;
            opacity: 0; /* Inicialmente oculto */
            visibility: hidden;
            transform: translateX(-100%); /* Ocultar fuera de la pantalla */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .channel-list-container.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(0); /* Mostrar deslizando desde la izquierda */
        }
        .app-logo {
            margin-bottom: 1rem;
            text-align: center; /* Centrar el logo */
        }
        .app-logo img {
            max-width: 80%; /* Ajustar tamaño del logo */
            height: auto;
            border-radius: 0.25rem; /* Bordes redondeados para la imagen */
        }
        .channel-list {
            flex-grow: 1; /* Ocupa el espacio restante */
            overflow-y: auto; /* Scroll si es necesario */
            padding-right: 0.5rem; /* Espacio para la barra de scroll */
        }
        .channel-item {
            display: flex; /* Usar flexbox para alinear imagen y texto */
            align-items: center; /* Alinear verticalmente */
            padding: 0.75rem 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 0.375rem; /* Bordes redondeados */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: 2px solid transparent; /* Borde para el foco */
        }
        .channel-item:hover {
            background-color: #4a5568; /* Fondo al pasar el ratón */
        }
        .channel-item.focused {
            background-color: #4a5568; /* Fondo al tener el foco */
            border-color: #63b3ed; /* Borde azul claro para el foco */
            outline: none; /* Elimina el outline por defecto */
        }
        .channel-logo {
            width: 40px; /* Tamaño fijo para el logo del canal */
            height: 40px;
            object-fit: contain; /* Asegura que la imagen se ajuste */
            margin-right: 0.75rem; /* Espacio entre logo y nombre */
            border-radius: 0.25rem; /* Bordes redondeados */
            background-color: rgba(255, 255, 255, 0.1); /* Fondo tenue para logos transparentes */
        }
        .channel-name {
            flex-grow: 1; /* Permite que el nombre ocupe el espacio restante */
            white-space: nowrap; /* Evita que el nombre se rompa en varias líneas */
            overflow: hidden; /* Oculta el texto que desborda */
            text-overflow: ellipsis; /* Añade puntos suspensivos si el texto es muy largo */
        }
        /* Estilo para la barra de scroll */
        .channel-list::-webkit-scrollbar {
            width: 8px;
        }
        .channel-list::-webkit-scrollbar-track {
            background: #2d3748;
            border-radius: 10px;
        }
        .channel-list::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 10px;
        }
        .channel-list::-webkit-scrollbar-thumb:hover {
            background: #63b3ed;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            z-index: 20; /* Encima de todo */
            display: none; /* Oculto por defecto */
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="video-container">
        <video id="videoPlayer" controls autoplay></video>
    </div>

    <div class="main-content w-full h-screen flex items-center justify-center text-gray-400 z-index-1">
        Presiona una tecla para mostrar la lista de canales
    </div>

     <div id="messageBox" class="message-box">
        <p id="messageText"></p>
    </div>


    <div id="channelListContainer" class="channel-list-container">
        <div class="app-logo">
            <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjtH1eFwNcBk9FvfM8ozeG6zjDtvJR2j2CdfNtfn8rj0JP9PRWR7zeL_ayD_dwmmuqOe8-sTp-TcOGCVsg5yhUNBO_PqRVI9gCMu3B1x2MQ1ZsitAg-1NKxQ70x3H-O9eehSCsQO6DzLPxcB_uZpfGmfziYNcXQ0JylvrGY1PE-sc9nJ76l2c62PG3Kcvs/w683-h203/JORGEDEZ-19-3-2025.png" alt="Logo JORGEDEZ">
        </div>
        <div class="channel-list" id="channelList">
            <p>Cargando canales...</p>
        </div>
    </div>

    <script>
        const m3uUrl = 'https://raw.githubusercontent.com/sejo48/retrom3u/refs/heads/main/listaoficial.m3u';
        const videoPlayer = document.getElementById('videoPlayer');
        const channelListContainer = document.getElementById('channelListContainer');
        const channelListElement = document.getElementById('channelList');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');

        let channels = [];
        let hideTimer = null;
        let focusedIndex = -1;
        let hlsPlayer = null; // Variable para la instancia de HLS.js

        // Función para mostrar un mensaje temporal
        function showMessage(message, duration = 2000) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }


        // Función para mostrar la lista y iniciar el temporizador
        function showList() {
            console.log("Mostrando lista de canales."); // Log de diagnóstico
            channelListContainer.classList.add('visible');
            // Asegurarse de que el foco esté en el primer elemento si hay canales
            if (channels.length > 0 && focusedIndex === -1) {
                focusedIndex = 0;
                updateFocus();
            }
            startHideTimer();
        }

        // Función para ocultar la lista
        function hideList() {
            console.log("Ocultando lista de canales."); // Log de diagnóstico
            channelListContainer.classList.remove('visible');
            clearHideTimer();
            // Opcional: quitar el foco cuando se oculta
            // removeFocus();
            // focusedIndex = -1;
        }

        // Función para iniciar o reiniciar el temporizador de ocultar
        function startHideTimer() {
            clearHideTimer(); // Limpiar temporizador existente si lo hay
            hideTimer = setTimeout(() => {
                hideList();
            }, 3000); // 3000 milisegundos = 3 segundos
        }

        // Función para limpiar el temporizador
        function clearHideTimer() {
            if (hideTimer) {
                clearTimeout(hideTimer);
                hideTimer = null;
            }
        }

        // Función para actualizar el foco en la lista
        function updateFocus() {
            const items = channelListElement.querySelectorAll('.channel-item');
            items.forEach((item, index) => {
                if (index === focusedIndex) {
                    item.classList.add('focused');
                    // Asegurar que el elemento enfocado sea visible (scroll into view)
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    item.classList.remove('focused');
                }
            });
        }

        // Función para quitar el foco de todos los elementos
        function removeFocus() {
             const items = channelListElement.querySelectorAll('.channel-item');
             items.forEach(item => item.classList.remove('focused'));
        }


        // Función para parsear el contenido M3U
        function parseM3u(m3uContent) {
            console.log("Intentando parsear contenido M3U."); // Log de diagnóstico
            const lines = m3uContent.split('\n');
            const parsedChannels = [];
            let currentChannel = {};

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#EXTINF')) {
                    // Extraer el nombre del canal
                    const nameMatch = trimmedLine.match(/,(.*)$/);
                     if (nameMatch && nameMatch[1]) {
                        currentChannel.name = nameMatch[1].trim();
                    }

                    // Extraer el logo (tvg-logo)
                    const logoMatch = trimmedLine.match(/tvg-logo="([^"]+)"/);
                    if (logoMatch && logoMatch[1]) {
                        currentChannel.logo = logoMatch[1];
                    } else {
                        currentChannel.logo = null; // No logo found
                    }

                } else if (trimmedLine && !trimmedLine.startsWith('#')) {
                    // La siguiente línea después de #EXTINF es la URL
                    if (currentChannel.name) { // Asegurarse de que haya un nombre antes de la URL
                        currentChannel.url = trimmedLine;
                        parsedChannels.push(currentChannel);
                        currentChannel = {}; // Reset para el siguiente canal
                    }
                }
            }
            console.log(`Parseo completado. Encontrados ${parsedChannels.length} canales.`); // Log de diagnóstico
            return parsedChannels;
        }

        // Función para renderizar la lista de canales en el DOM
        function renderChannelList(channelsToRender) {
            console.log(`Intentando renderizar ${channelsToRender.length} canales.`); // Log de diagnóstico
            channelListElement.innerHTML = ''; // Limpiar lista existente
            if (channelsToRender.length === 0) {
                channelListElement.innerHTML = '<p>No se encontraron canales en la lista M3U.</p>'; // Mensaje más específico
                console.log("No hay canales para renderizar."); // Log de diagnóstico
                return;
            }

            channelsToRender.forEach((channel, index) => {
                const channelItem = document.createElement('div');
                channelItem.classList.add('channel-item', 'text-gray-200');
                channelItem.dataset.url = channel.url;
                channelItem.dataset.index = index; // Guardar el índice para el foco

                // Añadir el logo si existe
                if (channel.logo) {
                    const channelLogo = document.createElement('img');
                    channelLogo.classList.add('channel-logo');
                    channelLogo.src = channel.logo;
                    channelLogo.alt = `${channel.name} logo`;
                    // Manejar error si la imagen no carga
                    channelLogo.onerror = function() {
                        this.style.display = 'none'; // Ocultar si falla la carga
                    };
                    channelItem.appendChild(channelLogo);
                }

                // Añadir el nombre del canal
                const channelName = document.createElement('span');
                channelName.classList.add('channel-name');
                channelName.textContent = channel.name;
                channelItem.appendChild(channelName);


                // Añadir evento de click (útil para mouse/touch, aunque el foco es para mando)
                channelItem.addEventListener('click', () => {
                    console.log('Seleccionado:', channel.name, channel.url);
                    playChannel(channel.url, channel.name); // Reproducir el canal al hacer click
                    hideList(); // Ocultar la lista después de seleccionar
                });

                channelListElement.appendChild(channelItem);
            });
            console.log("Renderizado de canales completado."); // Log de diagnóstico
        }

        // Función para cargar la lista M3U
        async function loadM3uList() {
            console.log(`Intentando cargar lista M3U desde: ${m3uUrl}`); // Log de diagnóstico
            try {
                const response = await fetch(m3uUrl);
                if (!response.ok) {
                    console.error(`Error HTTP! Estado: ${response.status}`); // Log de error
                    showMessage(`Error al cargar la lista: ${response.status}`, 3000); // Mostrar mensaje de error
                    throw new Error(`Error HTTP! status: ${response.status}`);
                }
                const m3uContent = await response.text();
                console.log("Contenido M3U cargado exitosamente."); // Log de diagnóstico
                channels = parseM3u(m3uContent);
                renderChannelList(channels);
                console.log(`Proceso de carga y renderizado finalizado. Canales encontrados: ${channels.length}.`); // Log de diagnóstico
                 if (channels.length === 0) {
                    showMessage("No se encontraron canales en la lista M3U.", 3000); // Mostrar mensaje si no hay canales
                }

            } catch (error) {
                console.error('Error al cargar la lista M3U:', error); // Log de error
                channelListElement.innerHTML = '<p class="text-red-400">Error al cargar los canales. Verifica la URL o el formato del archivo.</p>'; // Mensaje de error mejorado
                showMessage("Error al cargar los canales.", 3000); // Mostrar mensaje de error
            }
        }

        // Función para reproducir un canal usando HLS.js o el reproductor nativo
        function playChannel(url, channelName) {
            if (!videoPlayer) {
                 console.error("Elemento de video no encontrado."); // Log de error
                 showMessage("Error interno: reproductor no disponible.", 3000); // Mostrar mensaje de error
                 return;
            }

            console.log(`Intentando reproducir: ${url}`); // Log de diagnóstico
            showMessage(`Intentando reproducir: ${channelName}...`); // Mostrar mensaje en pantalla

            // Detener el reproductor HLS.js si existe
            if (hlsPlayer) {
                hlsPlayer.destroy();
                hlsPlayer = null;
            }

            // Intentar con HLS.js si es compatible y la URL parece ser HLS
            if (Hls.isSupported() && url.endsWith('.m3u8')) {
                hlsPlayer = new Hls();
                hlsPlayer.loadSource(url);
                hlsPlayer.attachMedia(videoPlayer);
                hlsPlayer.on(Hls.Events.MANIFEST_PARSED, function() {
                    console.log("HLS.js: MANIFEST_PARSED");
                    videoPlayer.play().catch(error => {
                        console.error('Error al intentar reproducir el video (HLS.js play):', error);
                        // El AbortError puede ocurrir aquí si CORS falla
                        if (error.name === 'AbortError') {
                             showMessage("Error de reproducción: Intento interrumpido (posible CORS).", 4000);
                        } else {
                            showMessage("No se pudo reproducir el canal (HLS).", 3000); // Mostrar mensaje de error de reproducción
                        }
                    });
                });
                 hlsPlayer.on(Hls.Events.ERROR, function (event, data) {
                    console.error('Error en HLS.js:', data);
                    let errorMessage = `Error en HLS: ${data.details}`;
                     if (data.details.includes('networkError') && data.details.includes('status:0')) {
                         errorMessage = "Error de red: Posible problema de CORS o conexión.";
                     } else if (data.details.includes('manifestLoadError')) {
                         errorMessage = "Error de carga del manifiesto HLS.";
                     } else if (data.details.includes('bufferAppendError')) {
                         errorMessage = "Error al procesar datos de video.";
                     }
                    showMessage(errorMessage, 4000);
                });
            } else {
                // Si HLS.js no es compatible o no es una URL HLS, intentar con el reproductor nativo
                videoPlayer.src = url;
                videoPlayer.play().catch(error => {
                    console.error('Error al intentar reproducir el video (nativo play):', error);
                     if (error.name === 'AbortError') {
                         showMessage("Error de reproducción: Intento interrumpido (posible CORS).", 4000);
                     } else {
                         showMessage("No se pudo reproducir el canal (nativo). Formato no soportado.", 3000); // Mostrar mensaje de error de reproducción
                     }
                });
            }
        }


        // Manejo de eventos de teclado (para mando a distancia)
        document.addEventListener('keydown', (event) => {
            console.log('Tecla presionada:', event.key, event.keyCode); // Para depuración

            // Ignorar eventos de teclado si el mensaje de error está visible
            if (messageBox.style.display === 'block') {
                // Permitir que la tecla Back/Backspace cierre el mensaje
                if (event.key === 'Backspace' || event.key === 'Back') {
                     messageBox.style.display = 'none';
                     event.preventDefault(); // Prevenir acción por defecto
                }
                return;
            }

            if (channelListContainer.classList.contains('visible')) {
                // La lista está visible, manejar navegación
                const items = channelListElement.querySelectorAll('.channel-item');
                if (items.length === 0) {
                    console.log("No hay elementos en la lista para enfocar."); // Log de diagnóstico
                    return;
                }

                switch (event.key) {
                    case 'ArrowDown':
                    case 'Down': // Algunas TVs usan 'Down'
                        event.preventDefault(); // Prevenir scroll por defecto
                        focusedIndex = (focusedIndex + 1) % items.length;
                        updateFocus();
                        startHideTimer(); // Reiniciar temporizador
                        console.log(`Foco movido a índice: ${focusedIndex}`); // Log de diagnóstico
                        break;
                    case 'ArrowUp':
                    case 'Up': // Algunas TVs usan 'Up'
                        event.preventDefault(); // Prevenir scroll por defecto
                        focusedIndex = (focusedIndex - 1 + items.length) % items.length;
                        updateFocus();
                        startHideTimer(); // Reiniciar temporizador
                        console.log(`Foco movido a índice: ${focusedIndex}`); // Log de diagnóstico
                        break;
                    case 'Enter':
                    case 'OK': // Algunas TVs usan 'OK'
                        event.preventDefault(); // Prevenir acción por defecto
                        if (focusedIndex !== -1 && channels[focusedIndex]) {
                            const selectedChannel = channels[focusedIndex];
                            console.log('Seleccionado con Enter/OK:', selectedChannel.name, selectedChannel.url);
                            playChannel(selectedChannel.url, selectedChannel.name); // Reproducir el canal seleccionado
                            hideList(); // Ocultar la lista después de seleccionar
                        } else {
                            console.log("No hay elemento enfocado o canal válido para seleccionar."); // Log de diagnóstico
                        }
                        // No reiniciar temporizador aquí si la acción esconde la lista
                        break;
                    case 'Backspace':
                    case 'Back': // Algunas TVs usan 'Back'
                        event.preventDefault(); // Prevenir acción por defecto
                        hideList(); // Ocultar la lista con el botón de retroceso
                        console.log("Lista oculta con Back/Backspace."); // Log de diagnóstico
                        break;
                    default:
                        // Para cualquier otra tecla, simplemente reiniciar el temporizador
                        startHideTimer();
                        console.log("Tecla no de navegación, reiniciando temporizador."); // Log de diagnóstico
                        break;
                }
            } else {
                // La lista está oculta, mostrarla al presionar cualquier tecla
                console.log("Lista oculta, mostrando al presionar tecla."); // Log de diagnóstico
                showList();
            }
        });

        // Cargar la lista M3U al inicio (la lista estará oculta inicialmente por CSS)
        window.onload = loadM3uList;

    </script>
</body>
</html>
